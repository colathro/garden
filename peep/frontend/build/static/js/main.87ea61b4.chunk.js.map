{"version":3,"sources":["components/WaterLevel.tsx","components/TempHumidity.tsx","App.tsx","index.tsx"],"names":["WaterLevelChart","useState","data","setData","useEffect","fetch","then","response","a","status","json","resp","output","sort","b","timestamp","currentHour","Date","setHours","getHours","currentHourSummary","sensor0","sensor0count","sensor1","sensor1count","sensor2","sensor2count","sensor3","sensor3count","forEach","record","sensor","voltage","push","summarizeData","LineChart","width","height","CartesianGrid","strokeDasharray","XAxis","dataKey","YAxis","Tooltip","Legend","Line","type","stroke","TempHumidityChart","temp","tempcount","humidity","humiditycount","console","log","activeDot","r","App","className","WaterLevel","TempHumidity","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.87ea61b4.chunk.js","sourcesContent":["import { useEffect } from 'react';\nimport { useState } from 'react';\nimport { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';\n\nconst summarizeData = (data: WaterLevel[]) => {\n    let output : HourSummary[] = [];\n    data.sort((a, b) => a.timestamp - b.timestamp)\n    let currentHour = new Date(data[0].timestamp*1000);\n    currentHour.setHours(currentHour.getHours() + 1)\n\n    let currentHourSummary : HourSummary = {\n        sensor0: 0,\n        sensor0count: 0,\n        sensor1: 0,\n        sensor1count: 0,\n        sensor2: 0,\n        sensor2count: 0,\n        sensor3: 0,\n        sensor3count: 0,\n        timestamp: currentHour\n    }\n    \n    data.forEach(record => {\n        if (new Date(record.timestamp*1000) < currentHourSummary.timestamp)\n        {\n            switch (record.sensor) {\n                case 0:\n                    currentHourSummary.sensor0count += 1;\n                    currentHourSummary.sensor0 += record.voltage;\n                break;\n                case 1:\n                    currentHourSummary.sensor1count += 1;\n                    currentHourSummary.sensor1 += record.voltage;\n                break;\n                case 2:\n                    currentHourSummary.sensor2count += 1;\n                    currentHourSummary.sensor2 += record.voltage;\n                break;\n                case 3:\n                    currentHourSummary.sensor3count += 1;\n                    currentHourSummary.sensor3 += record.voltage;\n                break;\n            }\n        }\n        else {\n            currentHourSummary.sensor0 = currentHourSummary.sensor0 / currentHourSummary.sensor0count;\n            currentHourSummary.sensor1 = currentHourSummary.sensor1 / currentHourSummary.sensor1count;\n            currentHourSummary.sensor2 = currentHourSummary.sensor2 / currentHourSummary.sensor2count;\n            currentHourSummary.sensor3 = currentHourSummary.sensor3 / currentHourSummary.sensor3count;\n\n            output.push(currentHourSummary);\n\n            currentHour = new Date(currentHour.setHours(currentHour.getHours() + 1));\n            \n            currentHourSummary = {\n                sensor0: 0,\n                sensor0count: 0,\n                sensor1: 0,\n                sensor1count: 0,\n                sensor2: 0,\n                sensor2count: 0,\n                sensor3: 0,\n                sensor3count: 0,\n                timestamp: currentHour\n            }\n        }\n    });\n\n    return output;\n}\n\ntype WaterLevel = {\n    sensor: number;\n    voltage: number;\n    timestamp: number;\n}\n\ntype HourSummary = {\n    sensor0: number;\n    sensor0count: number;\n    sensor1: number;\n    sensor1count: number;\n    sensor2: number;\n    sensor2count: number;\n    sensor3: number;\n    sensor3count: number;\n    timestamp: Date;\n}\n\nconst WaterLevelChart = () => {\n    const [data, setData] = useState<HourSummary[]>();\n    useEffect(() => {\n        fetch('api/water/week').then(async (response) => {\n            if (response.status === 400) {\n              return null;\n            }\n            const resp = await response.json();\n            return resp;\n          })\n          .then((data:WaterLevel[]) => {\n            if (data != null) {\n              setData(summarizeData(data));         }\n          });\n    }, [])\n    return (\n        <LineChart\n          width={800}\n          height={400}\n          data={data}\n        >\n          <CartesianGrid strokeDasharray=\"3 3\" />\n          <XAxis dataKey=\"timestamp\"/>\n          <YAxis />\n          <Tooltip />\n          <Legend />\n          <Line type=\"monotone\" dataKey=\"sensor0\" stroke=\"#0FD65B\"  />\n          <Line type=\"monotone\" dataKey=\"sensor1\" stroke=\"#A90FD6\"  />\n          <Line type=\"monotone\" dataKey=\"sensor2\" stroke=\"#D60F2A\"  />\n          <Line type=\"monotone\" dataKey=\"sensor3\" stroke=\"#E27B1F\"  />\n        </LineChart>\n    );\n}\n\nexport default WaterLevelChart;\n","import { useEffect } from 'react';\nimport { useState } from 'react';\nimport { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';\n\nconst summarizeData = (data: TempHumid[]) => {\n    let output : HourSummary[] = [];\n    data.sort((a, b) => a.timestamp - b.timestamp)\n    let currentHour = new Date(data[0].timestamp*1000);\n    currentHour.setHours(currentHour.getHours() + 1)\n\n    let currentHourSummary : HourSummary = {\n        temp: 0,\n        tempcount: 0,\n        humidity: 0,\n        humiditycount: 0,\n        timestamp: currentHour\n    }\n    \n    data.forEach(record => {\n        if (new Date(record.timestamp*1000) < currentHourSummary.timestamp)\n        {\n            currentHourSummary.tempcount += 1;\n            currentHourSummary.temp += record.temp;\n\n            currentHourSummary.humiditycount += 1;\n            currentHourSummary.humidity += record.humidity;\n        }\n        else {\n            currentHourSummary.temp = currentHourSummary.temp / currentHourSummary.tempcount;\n            currentHourSummary.humidity = currentHourSummary.humidity / currentHourSummary.humiditycount;\n\n            output.push(currentHourSummary);\n\n            currentHour = new Date(currentHour.setHours(currentHour.getHours() + 1));\n            \n            currentHourSummary = {\n                temp: 0,\n                tempcount: 0,\n                humidity: 0,\n                humiditycount: 0,\n                timestamp: currentHour\n            }\n        }\n    });\n\n    console.log(output);\n    return output;\n}\n\ntype TempHumid = {\n    humidity: number;\n    temp: number;\n    timestamp: number;\n}\n\ntype HourSummary = {\n    temp: number;\n    tempcount: number;\n    humidity: number;\n    humiditycount: number;\n    timestamp: Date;\n}\n\nconst TempHumidityChart = () => {\n    const [data, setData] = useState<HourSummary[]>();\n    useEffect(() => {\n        fetch('/api/temphumid/all').then(async (response) => {\n            if (response.status === 400) {\n              return null;\n            }\n            const resp = await response.json();\n            return resp;\n          })\n          .then((data:TempHumid[]) => {\n            if (data != null) {\n              setData(summarizeData(data));         }\n          });\n    }, [])\n    return (\n        <LineChart\n          width={800}\n          height={400}\n          data={data}\n        >\n          <CartesianGrid strokeDasharray=\"3 3\" />\n          <XAxis dataKey=\"timestamp\" />\n          <YAxis />\n          <Tooltip />\n          <Legend />\n          <Line type=\"monotone\" dataKey=\"temp\" stroke=\"#FF5733\" activeDot={{ r: 8 }} />\n          <Line type=\"monotone\" dataKey=\"humidity\" stroke=\"#3386FF\" activeDot={{ r: 8 }} />\n        </LineChart>\n    );\n}\n\nexport default TempHumidityChart;\n","import WaterLevelChart from \"./components/WaterLevel\";\nimport TempHumidityChart from \"./components/TempHumidity\";\n\nfunction App() {\n  return (\n    <div className=\"app\">\n        <WaterLevelChart/>\n        <TempHumidityChart/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals"],"sourceRoot":""}